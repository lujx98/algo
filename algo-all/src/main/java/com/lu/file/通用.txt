向上取整   (x + y - 1) / y
-----------------------------------------------------------------------------------
对于字符串拆分 数组拆分
所有的拆分 使用左闭右开区间进行拆分
对于数组 012345
对index = 1进行拆分 拆分出来的元素为 0 与 12345
jdk内的api也同样是以左闭右开的区间进行拆分

见q判断是否能拆分数组
-----------------------------------------------------------------------------------
为什么return (int) (ans % (1e9 + 7))不行但是return (int) (ans % 1000000007)可以
因为(1e9)是浮点型有精度问题，占用字节数少的代价是精度缺失，可以用 return (int) (ans % (int)(1e9 + 7))
-----------------------------------------------------------------------------------
Array.stream().sum() long会溢出  只能算int类型的数据

int offset = 0;
boolean[] booleans = new boolean[26];
for (char c : substring.toCharArray()) {
    if (booleans[c - 'a']) {
        offset++;
        booleans[c - 'a'] = false;
    } else {
        booleans[c - 'a'] = true;
    }
}
可以用异或替代
-----------------------------------------------------------------------------------
对于String.substring方法  得到的子字符串是一个左闭右开的区间
-----------------------------------------------------------------------------------
n≤30            指数级别, dfs+剪枝、状态压缩dp
n≤100           O(n^3)，floyd、dp
n≤10^3          O(n^2),O(n*logn)，dp、二分，朴素版Dijkstra、朴素版Prim、Bellman-Ford
n≤10^4          O(n∗√n) ,O(n^2)，块状链表、分块、莫队
n≤10^5          O(n*logn) ，各种sort、线段树、树状数组、set/map、heap、拓扑排序、dijkstra+heap、prim+heap、spfa、求凸包、求半平面交、二分
n≤10^6          O(n), 以及常数较小的 O(nlogn)算法 => hash、双指针扫描、并查集，kmp、AC自动机，常数比较小的 O(nlogn)的做法：sort、树状数组、heap、dijkstra、spfa
n≤10^7          O(n)，双指针扫描、kmp、AC自动机、线性筛素数
n≤10^9          O(√n) O(n)，判断质数
n≤10^18         O(logn)，最大公约数、快速幂
n≤10^1000       O((logn)2)，高精度加减乘除
n≤10^100000     O(logn*log(logn))，高精度加减、FFT/NTT
----------------------------------
质数遍历判断只需要判断到n^(1/2)就可以。比如判断100是否为质数，只需要判断到10以内有没有数可以整除就好。